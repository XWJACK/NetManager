//
//  GetMAC.c
//  NetManager
//
//  Created by XWJACK on 3/12/16.
//  Copyright Â© 2016 XWJACK. All rights reserved.
//

#include "GetMAC.h"

/**
 *  This function was finded in stackoverflow.
 *  How do I query the ARP table on iPhone?:http://stackoverflow.com/questions/2258172/how-do-i-query-the-arp-table-on-iphone
 *  Getting ARP table on iPhone/iPad:http://stackoverflow.com/questions/10395041/getting-arp-table-on-iphone-ipad
 *  I samplified this code and fixed some memory leak.
 *
 *
 *  @param addr IP Address
 *  @param back MAC Address
 *
 *  @return if error return -1 ,else return 0
 */
int ctoMACAddress(in_addr_t addr, char *back) {
    char *buf,*next;
    size_t needed;
    
    struct rt_msghdr *rtm;
    struct sockaddr_inarp *sin;
    struct sockaddr_dl *sdl;
    
    int mib[6] = {
        CTL_NET,//Top-level identifiers  network
        PF_ROUTE,//Protocol families, same as address families for now.
        0,
        AF_INET,//internetwork: UDP, TCP
        NET_RT_FLAGS,//PF_ROUTE - Routing table
        RTF_LLINFO//generated by link layer
    };
    
    if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
        printf("route-sysctl-estimate");
        return -1;
    }
    if ((buf = (char *)malloc(needed)) == NULL) {
        printf("malloc");
        return -1;
    }
    if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
        printf("retrieval of routing table");
        free(buf);
        return -1;
    }
    
    for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
        
        rtm = (struct rt_msghdr *)next;
        sin = (struct sockaddr_inarp *)(rtm + 1);
        sdl = (struct sockaddr_dl *)(sin + 1);
        
        if (addr != sin->sin_addr.s_addr || sdl->sdl_alen < 6) { continue; }
        
        u_char *cp = (u_char*)LLADDR(sdl);
        
        //ret = [NSString stringWithFormat:@"%02X:%02X:%02X:%02X:%02X:%02X",cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]];
        sprintf(back, "%02X:%02X:%02X:%02X:%02X:%02X", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
        break;
    }
    if (next >= buf + needed) {
        free(buf);
        return -1;
    }
    
    free(buf);
    return 0;
}